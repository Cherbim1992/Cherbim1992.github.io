[{"title":"2018年2月随笔","date":"2018-02-27T12:21:47.000Z","path":"2018/02/27/write01/","text":"好久没更新博客了,平时做项目很忙,博客也是疏于打理吧,github也没有经常更新代码，本身每天做项目也是很疲惫,没有能随手记录,每一个功能,每一个bug是如何解决的,很惭愧。然后呢我的简历上也是没有很详细的说清我的项目,那现在已经待业了嘛,我也还是不会放弃学习的就这样一边学习一边把我工作这段时间沉淀的一些东西记录分享一下吧,能贴代码展示就贴贴代码！ 代码部分1if(coder)&#123;return \"coder\"&#125;","tags":[{"name":"write","slug":"write","permalink":"https://cherbim1992.github.io/tags/write/"}]},{"title":"学习笔记003","date":"2017-07-26T14:44:28.000Z","path":"2017/07/26/study03/","text":"快速掌握es5/es6的一些简单方法(3) 除了看上去更简洁以外，arrow function还有一项超级无敌的功能！长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。例如：123456789101112class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; setTimeout(function()&#123; console.log(this.type + ' says ' + say) &#125;, 1000) &#125;&#125;var animal = new Animal() animal.says('hi') //undefined says hi 运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种： 1.第一种是将this传给self,再用self来指代this12345says(say)&#123; var self = this; setTimeout(function()&#123; console.log(self.type + ' says ' + say) &#125;, 1000) 2.第二种方法是用bind(this),即1234says(say)&#123; setTimeout(function()&#123; console.log(this.type + ' says ' + say) &#125;.bind(this), 1000) 但现在我们有了箭头函数，就不需要这么麻烦了：123456789101112class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; setTimeout( () =&gt; &#123; console.log(this.type + ' says ' + say) &#125;, 1000) &#125;&#125; var animal = new Animal() animal.says('hi') //animal says hi 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。 template string这个东西也是非常有用当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如mustache等等。123456$(\"#result\").append( \"There are &lt;b&gt;\" + basket.count + \"&lt;/b&gt; \" + \"items in your basket, \" + \"&lt;em&gt;\" + basket.onSale + \"&lt;/em&gt; are on sale!\"); 我们要用一堆的’+’号来连接文本与变量，而使用ES6的新特性模板字符串``后，我们可以直接这么来写：12345$(\"#result\").append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 我们要用一堆的’+’号来连接文本与变量，而使用ES6的新特性模板字符串``后，我们可以直接这么来写：12345$(\"#result\").append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 用反引号（\\）来标识起始，用${}`来引用变量，而且所有的空格和缩进都会被保留在输出之中，是不是非常爽？！1&lt;Link to=&#123;`/taco/$&#123;taco.name&#125;`&#125;&gt;&#123;taco.name&#125;&lt;/Link&gt; destructuringES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。1234let cat = 'ken'let dog = 'lili'let zoo = &#123;cat: cat, dog: dog&#125;console.log(zoo) //Object &#123;cat: \"ken\", dog: \"lili\"&#125; 用ES6完全可以像下面这么写：1234let cat = 'ken'let dog = 'lili'let zoo = &#123;cat, dog&#125;console.log(zoo) //Object &#123;cat: \"ken\", dog: \"lili\"&#125; 反过来可以这么写：123let dog = &#123;type: 'animal', many: 2&#125;let &#123; type, many&#125; = dogconsole.log(type, many) //animal 2 default, restdefault很简单，意思就是默认值。大家可以看下面的例子，调用animal()方法时忘了传参数，传统的做法就是加上这一句type = type || ‘cat’ 来指定默认值。12345function animal(type)&#123; type = type || 'cat' console.log(type)&#125;animal() 如果用ES6我们而已直接这么写：1234function animal(type = 'cat')&#123; console.log(type)&#125;animal() 最后一个rest语法也很简单，直接看例子：1234function animals(...types)&#123; console.log(types)&#125;animals('cat', 'dog', 'fish') //[\"cat\", \"dog\", \"fish\"] 而如果不用ES6的话，我们则得使用ES5的arguments。 以上就是ES6最常用的一些语法，可以说这20%的语法，在ES6的日常使用中占了80%… 给自己晚安。","tags":[{"name":"start","slug":"start","permalink":"https://cherbim1992.github.io/tags/start/"}]},{"title":"学习笔记002","date":"2017-07-25T15:51:35.000Z","path":"2017/07/25/study02/","text":"快速掌握es5/es6的一些简单方法(2) class, extends, super 这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承… 有了ES6我们不再烦恼！ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。123456789101112131415161718192021class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; console.log(this.type + ' says ' + say) &#125;&#125;let animal = new Animal()animal.says('hello') //animal says helloclass Cat extends Animal &#123; constructor()&#123; super() this.type = 'cat' &#125;&#125;let cat = new Cat()cat.says('hello') //cat says hello 上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。 super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 arrow functionES6最最常用的一个新特性了，用它来写function比原来的写法要简洁清晰很多:12function(i)&#123; return i + 1; &#125; //ES5(i) =&gt; i + 1 //ES6 简直是简单的不像话对吧…如果方程比较复杂，则需要用{}把代码包起来：123456function(x, y) &#123; x++; y--; return x + y;&#125;(x, y) =&gt; &#123;x++; y--; return x+y&#125; 后面还有箭头函数以及``template string 明天再继续吧！","tags":[{"name":"start","slug":"start","permalink":"https://cherbim1992.github.io/tags/start/"}]},{"title":"学习笔记001","date":"2017-07-24T15:43:10.000Z","path":"2017/07/24/study01/","text":"快速掌握es5/es6的一些简单方法(1) let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments这些是ES6最常用的几个语法，基本上学会它们就Oklet, const这两个的用途与var类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。首先来看下面这个例子： 12345678910var name = 'zach'while (true) &#123; var name = 'obama' console.log(name) //obama break&#125;console.log(name) //obama 使用var 两次输出都是obama，这是因为ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景就是你现在看到的内层变量覆盖外层变量。而let则实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块内有效。12345678910let name = 'zach'while (true) &#123; let name = 'obama' console.log(name) //obama break&#125;console.log(name) //zach 另外一个var带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子：1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 再来看一个更常见的例子，了解下如果不用ES6，而用闭包如何解决这个问题。123456var clickBoxs = document.querySelectorAll('.clickBox')for (var i = 0; i &lt; clickBoxs.length; i++)&#123; clickBoxs[i].onclick = function()&#123; console.log(i) &#125;&#125; 我们本来希望的是点击不同的clickBox，显示不同的i，但事实是无论我们点击哪个clickBox，输出的都是5。下面我们来看下，如何用闭包搞定它。12345678910function iteratorFactory(i)&#123; var onclick = function(e)&#123; console.log(i) &#125; return onclick;&#125;var clickBoxs = document.querySelectorAll('.clickBox')for (var i = 0; i &lt; clickBoxs.length; i++)&#123; clickBoxs[i].onclick = iteratorFactory(i)&#125; const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。123const PI = Math.PIPI = 23 //Module build failed: SyntaxError: /es6/app.js: \"PI\" is read-only 当我们尝试去改变用const声明的常量时，浏览器就会报错。const有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用const来声明可以避免未来不小心重命名而导致出现bug：1const monent = require('moment'); 明天更新剩余部分吧 睡觉了~~","tags":[{"name":"start","slug":"start","permalink":"https://cherbim1992.github.io/tags/start/"}]},{"title":"用我的小博客学习知识","date":"2017-07-18T15:24:35.000Z","path":"2017/07/18/start/","text":"学习知识 学习知识 学习知识 123if(study)&#123; return \"success\";&#125;","tags":[{"name":"start","slug":"start","permalink":"https://cherbim1992.github.io/tags/start/"}]},{"title":"markdown写博客","date":"2017-03-22T13:31:46.000Z","path":"2017/03/22/web/","text":"这博客弄了很晚了….今天很晚了,有点困,不过把搜索功能弄完了，真的是越学习越感觉自己知道的很少，接下来要把markdown文档熟悉一下，来写博客,每天进步一点点吧~！","tags":[{"name":"markdown","slug":"markdown","permalink":"https://cherbim1992.github.io/tags/markdown/"}]},{"title":"第一个博客的Hello World","date":"2017-03-19T12:57:35.000Z","path":"2017/03/19/Hello/","text":"摘要:这是我的第一篇博客！~~~完美的开始是成功的第一步正文:完美的开始1111 代码1if(test)&#123;return \"test\"&#125;","tags":[{"name":"first","slug":"first","permalink":"https://cherbim1992.github.io/tags/first/"}]}]